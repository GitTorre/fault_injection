
%%%%%%%%%%%%%%
%     INTRODUCTION      %
%%%%%%%%%%%%%%

\section{Introduction}
In a world characterized by increasingly powerful and increasingly distributed applications, the cost of failure translates very directly into devastating repercussions. Violations in software correctness could cost Facebook millions in ad revenue by the hour, Amazon tens of millions by the hour if the day happens to be Black Friday, or cause an unfortunate administrator to have to wake up in the middle of the night to fix the problem \kmd{need real examples with citations; (extra attention-grabbing boost) give example of devastating non-monetary costs. Has anyone died because of distributed system failures?}. Accordingly, the benefits of thorough testing translate into very valuable defenses protecting large quantities of revenue against the hands of fate. Companies typically invest in active testing techniques in the form of a fault injection framework as a preferred method for challenging the correctness guarantees of distributed services and, in the process, preempt the manifestation of potentially devastating software errors. However, modern fault injection frameworks are not intelligent enough to maximally identify a set of existing failure scenarios within the time constraints of a production environment. Tools like Netflix's ChaosMonkey\cite{netflix:chaosmonkey} are unlikely to find certain errors caused by intricate combinations of failures\cite{alvaro:ldfi} and suffer unknown soundness and completeness guarantees due to a crippling reliance upon randomness. Additionally, fault injection frameworks such as Orchestra\cite{orchestra} require developers divert the time and energy from forward-driving design and implementation problems toward the inconvenient and tedious task of application-level instrumentation. 
\\ \indent
An ideal fault injection system design allows the careful targeting of individual components for particular failures, requires little work to integrate into the overall service, and outputs traces of the whole system as a result of individual experiments. To realize these goals, we propose \textit{Request Level Fault Injection} as a tracing system with an integrated fault injection component to provide both fine-grained fault injection and traces. 


%%%%%%%
%    EOF     %
%%%%%%%